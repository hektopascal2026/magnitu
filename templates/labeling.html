{% extends "layout.html" %}
{% block title %}Label â€” Magnitu{% endblock %}

{% block content %}
<!-- Progress Bar -->
<div class="progress-section">
    <div class="progress-stats">
        <span class="progress-today">Today: <strong id="todayCount">{{ today_labels }}</strong></span>
        <span class="progress-total">Total: <strong>{{ label_count }}</strong></span>
        <span class="progress-remaining">Queue: <strong id="queueCount">{{ unlabeled_count }}</strong></span>
    </div>
    <div class="progress-bar">
        {% set pct = (label_count / (label_count + unlabeled_count) * 100) if (label_count + unlabeled_count) > 0 else 0 %}
        <div class="progress-fill" style="width: {{ pct | round(1) }}%"></div>
    </div>
    <div class="progress-actions">
        <button class="btn btn-primary" id="syncPullBtn" title="Fetch new entries from Seismo">Sync</button>
        {% if label_count >= (config.min_labels_to_train or 20) %}
            <button class="btn" id="trainBtn" title="Train model on labeled entries">Train</button>
            {% if active_model %}
                <button class="btn" id="pushBtn" title="Push scores + recipe to Seismo">Push to Seismo</button>
            {% endif %}
        {% else %}
            <button class="btn" disabled title="Need {{ config.min_labels_to_train or 20 }} labels to train (have {{ label_count }})">Train ({{ label_count }}/{{ config.min_labels_to_train or 20 }})</button>
        {% endif %}
    </div>
</div>

<!-- Label Distribution -->
{% if label_distribution %}
<div class="label-dist">
    {% for label, count in label_distribution.items() %}
        <span class="label-dist-item label-{{ label }}">
            {{ label | replace('_', ' ') }}: {{ count }}
        </span>
    {% endfor %}
</div>
{% endif %}

<!-- Smart Queue Summary -->
{% if has_model and sampling_stats %}
<div class="sampling-bar">
    <span class="sampling-bar-label">Smart Queue</span>
    {% if sampling_stats.get('uncertain', 0) > 0 %}
        <span class="sampling-pill sampling-pill-uncertain">
            <span class="sampling-pill-count">{{ sampling_stats.uncertain }}</span> uncertain
        </span>
    {% endif %}
    {% if sampling_stats.get('conflict', 0) > 0 %}
        <span class="sampling-pill sampling-pill-conflict">
            <span class="sampling-pill-count">{{ sampling_stats.conflict }}</span> conflict
        </span>
    {% endif %}
    {% if sampling_stats.get('diverse', 0) > 0 %}
        <span class="sampling-pill sampling-pill-diverse">
            <span class="sampling-pill-count">{{ sampling_stats.diverse }}</span> diverse
        </span>
    {% endif %}
    {% if sampling_stats.get('new', 0) > 0 %}
        <span class="sampling-pill sampling-pill-new">
            <span class="sampling-pill-count">{{ sampling_stats.new }}</span> new
        </span>
    {% endif %}
</div>
{% endif %}

<!-- Entry Cards -->
<div class="entries-section" id="entriesSection">
    {% if entries %}
        {% for entry in entries %}
            <div class="entry-card {% if entry._label %}labeled labeled-{{ entry._label }}{% endif %}"
                 data-entry-type="{{ entry.entry_type }}"
                 data-entry-id="{{ entry.entry_id }}"
                 data-sampling-reason="{{ entry._sampling_reason or 'new' }}"
                 id="card-{{ entry.entry_type }}-{{ entry.entry_id }}">
                <div class="entry-header">
                    <span class="entry-source-tag source-{{ entry.source_type }}">
                        {{ entry.source_type }}
                    </span>
                    {% if entry.source_category %}
                        <span class="entry-category">{{ entry.source_category }}</span>
                    {% endif %}
                    {% if entry._sampling_reason and entry._sampling_reason != 'new' %}
                        <span class="sampling-reason sampling-reason-{{ entry._sampling_reason }}">
                            {{ entry._sampling_reason }}
                        </span>
                        {% if entry._sampling_detail %}
                            <span class="sampling-detail">{{ entry._sampling_detail }}</span>
                        {% endif %}
                    {% endif %}
                    {% if entry._label %}
                        <span class="entry-current-label label-{{ entry._label }}">
                            {{ entry._label | replace('_', ' ') }}
                        </span>
                    {% endif %}
                    {% if entry.published_date %}
                        <span class="entry-date">{{ entry.published_date[:10] }}</span>
                    {% endif %}
                </div>

                <h3 class="entry-title">
                    {% if entry.link %}
                        <a href="{{ entry.link }}" target="_blank" rel="noopener">{{ entry.title }}</a>
                    {% else %}
                        {{ entry.title }}
                    {% endif %}
                </h3>

                {% if entry.description %}
                    <div class="entry-content">{{ entry.description[:300] }}{% if entry.description|length > 300 %}...{% endif %}</div>
                {% endif %}

                {% if entry.source_name %}
                    <div class="entry-source">{{ entry.source_name }}</div>
                {% endif %}

                <div class="reasoning-row">
                    <input type="text" class="reasoning-input"
                           placeholder="{% if entry._label == 'investigation_lead' %}Why is this relevant?{% else %}Optional: why this label?{% endif %}"
                           value="{{ entry._reasoning or '' }}"
                           data-entry-type="{{ entry.entry_type }}"
                           data-entry-id="{{ entry.entry_id }}"
                           title="Optional reasoning (key: r to focus)">
                </div>
                <div class="label-buttons">
                    <button class="label-btn label-btn-investigation {% if entry._label == 'investigation_lead' %}active{% endif %}"
                            data-label="investigation_lead"
                            title="Investigation lead (key 1)">
                        <span class="label-key">1</span> Investigation
                    </button>
                    <button class="label-btn label-btn-important {% if entry._label == 'important' %}active{% endif %}"
                            data-label="important"
                            title="Important (key 2)">
                        <span class="label-key">2</span> Important
                    </button>
                    <button class="label-btn label-btn-background {% if entry._label == 'background' %}active{% endif %}"
                            data-label="background"
                            title="Background (key 3)">
                        <span class="label-key">3</span> Background
                    </button>
                    <button class="label-btn label-btn-noise {% if entry._label == 'noise' %}active{% endif %}"
                            data-label="noise"
                            title="Noise (key 4)">
                        <span class="label-key">4</span> Noise
                    </button>
                </div>
            </div>
        {% endfor %}
    {% else %}
        <div class="empty-state">
            <p>No entries in the queue. Click <strong>Sync</strong> to fetch entries from Seismo.</p>
        </div>
    {% endif %}
</div>
{% endblock %}

{% block scripts %}
<script>
(function() {
    var focusedCard = null;
    var cards = document.querySelectorAll('.entry-card');
    var todayEl = document.getElementById('todayCount');
    var queueEl = document.getElementById('queueCount');
    var todayCount = {{ today_labels }};
    var queueCount = {{ unlabeled_count }};

    // Focus first unlabeled card
    function focusFirstUnlabeled() {
        for (var i = 0; i < cards.length; i++) {
            if (!cards[i].classList.contains('labeled')) {
                setFocus(cards[i]);
                return;
            }
        }
        // All labeled, focus first card
        if (cards.length > 0) setFocus(cards[0]);
    }

    function setFocus(card) {
        if (focusedCard) focusedCard.classList.remove('focused');
        focusedCard = card;
        if (card) {
            card.classList.add('focused');
            card.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    }

    function nextCard() {
        if (!focusedCard) { focusFirstUnlabeled(); return; }
        var idx = Array.from(cards).indexOf(focusedCard);
        for (var i = idx + 1; i < cards.length; i++) {
            if (!cards[i].classList.contains('labeled')) {
                setFocus(cards[i]);
                return;
            }
        }
        // Wrap or stay
        focusFirstUnlabeled();
    }

    function prevCard() {
        if (!focusedCard) { focusFirstUnlabeled(); return; }
        var idx = Array.from(cards).indexOf(focusedCard);
        for (var i = idx - 1; i >= 0; i--) {
            if (!cards[i].classList.contains('labeled')) {
                setFocus(cards[i]);
                return;
            }
        }
    }

    // Label an entry
    function labelEntry(card, label) {
        var entryType = card.dataset.entryType;
        var entryId = card.dataset.entryId;
        var wasLabeled = card.classList.contains('labeled');

        // Get reasoning text from the input field
        var reasoningInput = card.querySelector('.reasoning-input');
        var reasoning = reasoningInput ? reasoningInput.value.trim() : '';

        var formData = new FormData();
        formData.append('entry_type', entryType);
        formData.append('entry_id', entryId);
        formData.append('label', label);
        formData.append('reasoning', reasoning);

        fetch('/api/label', { method: 'POST', body: formData })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.success) {
                    // Update card visuals
                    card.className = 'entry-card labeled labeled-' + label;
                    if (card === focusedCard) card.classList.add('focused');

                    // Update buttons
                    card.querySelectorAll('.label-btn').forEach(function(btn) {
                        btn.classList.toggle('active', btn.dataset.label === label);
                    });

                    // Update current label badge
                    var badge = card.querySelector('.entry-current-label');
                    if (!badge) {
                        badge = document.createElement('span');
                        badge.className = 'entry-current-label';
                        card.querySelector('.entry-header').appendChild(badge);
                    }
                    badge.className = 'entry-current-label label-' + label;
                    badge.textContent = label.replace(/_/g, ' ');

                    // Update counters
                    if (!wasLabeled) {
                        todayCount++;
                        queueCount = Math.max(0, queueCount - 1);
                        todayEl.textContent = todayCount;
                        queueEl.textContent = queueCount;
                    }

                    // Auto-advance to next unlabeled card
                    setTimeout(nextCard, 150);
                }
            })
            .catch(function(err) {
                flash('Error labeling entry: ' + err.message, 'error');
            });
    }

    // Click handlers for label buttons
    document.addEventListener('click', function(e) {
        var btn = e.target.closest('.label-btn');
        if (!btn) return;
        var card = btn.closest('.entry-card');
        labelEntry(card, btn.dataset.label);
    });

    // Keyboard shortcuts
    document.addEventListener('keydown', function(e) {
        // If in reasoning input, only handle Escape (to blur) and Enter (to submit)
        if (e.target.classList.contains('reasoning-input')) {
            if (e.key === 'Escape') {
                e.target.blur();
                e.preventDefault();
            }
            return;
        }
        // Don't capture if typing in other inputs
        if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') return;

        var labelMap = { '1': 'investigation_lead', '2': 'important', '3': 'background', '4': 'noise' };

        if (labelMap[e.key] && focusedCard) {
            e.preventDefault();
            labelEntry(focusedCard, labelMap[e.key]);
        } else if (e.key === 'r' && focusedCard) {
            // Focus the reasoning input of the current card
            e.preventDefault();
            var input = focusedCard.querySelector('.reasoning-input');
            if (input) input.focus();
        } else if (e.key === 'ArrowDown' || e.key === 'j') {
            e.preventDefault();
            nextCard();
        } else if (e.key === 'ArrowUp' || e.key === 'k') {
            e.preventDefault();
            prevCard();
        } else if (e.key === 'u' && focusedCard) {
            // Undo label
            e.preventDefault();
            var entryType = focusedCard.dataset.entryType;
            var entryId = focusedCard.dataset.entryId;
            var formData = new FormData();
            formData.append('entry_type', entryType);
            formData.append('entry_id', entryId);
            fetch('/api/unlabel', { method: 'POST', body: formData })
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    if (data.success) {
                        focusedCard.className = 'entry-card focused';
                        focusedCard.querySelectorAll('.label-btn').forEach(function(btn) {
                            btn.classList.remove('active');
                        });
                        var badge = focusedCard.querySelector('.entry-current-label');
                        if (badge) badge.remove();
                        queueCount++;
                        todayCount = Math.max(0, todayCount - 1);
                        todayEl.textContent = todayCount;
                        queueEl.textContent = queueCount;
                    }
                });
        }
    });

    // Sync button
    document.getElementById('syncPullBtn').addEventListener('click', function() {
        this.disabled = true;
        this.textContent = 'Syncing...';
        fetch('/api/sync/pull', { method: 'POST' })
            .then(function(r) { return r.json(); })
            .then(function(data) {
                if (data.success) {
                    flash('Fetched ' + data.entries_fetched + ' entries from Seismo.', 'success');
                    setTimeout(function() { location.reload(); }, 1000);
                } else {
                    flash('Sync failed: ' + (data.detail || 'Unknown error'), 'error');
                }
            })
            .catch(function(err) { flash('Sync error: ' + err.message, 'error'); })
            .finally(function() {
                document.getElementById('syncPullBtn').disabled = false;
                document.getElementById('syncPullBtn').textContent = 'Sync';
            });
    });

    // Train button
    var trainBtn = document.getElementById('trainBtn');
    if (trainBtn) {
        trainBtn.addEventListener('click', function() {
            this.disabled = true;
            this.textContent = 'Training...';
            fetch('/api/train', { method: 'POST' })
                .then(function(r) {
                    if (!r.ok) {
                        return r.text().then(function(t) {
                            throw new Error('Server error ' + r.status + ': ' + t.substring(0, 200));
                        });
                    }
                    return r.json();
                })
                .then(function(data) {
                    if (data.success) {
                        flash('Model v' + data.version + ' trained! Accuracy: ' + (data.accuracy * 100).toFixed(1) + '%, F1: ' + (data.f1_score * 100).toFixed(1) + '%', 'success');
                        setTimeout(function() { location.reload(); }, 1500);
                    } else {
                        flash('Training failed: ' + (data.error || 'Unknown error'), 'error');
                    }
                })
                .catch(function(err) { flash('Training error: ' + err.message, 'error'); })
                .finally(function() {
                    trainBtn.disabled = false;
                    trainBtn.textContent = 'Train';
                });
        });
    }

    // Push button
    var pushBtn = document.getElementById('pushBtn');
    if (pushBtn) {
        pushBtn.addEventListener('click', function() {
            this.disabled = true;
            this.textContent = 'Pushing...';
            fetch('/api/sync/push', { method: 'POST' })
                .then(function(r) { return r.json(); })
                .then(function(data) {
                    if (data.success) {
                        flash('Pushed ' + data.scores_pushed + ' scores to Seismo.', 'success');
                    } else {
                        flash('Push failed: ' + (data.detail || 'Unknown error'), 'error');
                    }
                })
                .catch(function(err) { flash('Push error: ' + err.message, 'error'); })
                .finally(function() {
                    pushBtn.disabled = false;
                    pushBtn.textContent = 'Push to Seismo';
                });
        });
    }

    // Auto-focus first unlabeled card
    focusFirstUnlabeled();
})();
</script>
{% endblock %}
